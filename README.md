# RPulse

С помощью библиотеки можно отправлять через последовательный интерфейс информацию с пинов микроконтроллера и значения выбранных переменных.

Перед началом работы скетча можно отправить набор параметров, которые затем используются в программе. Таким образом отпадает необходимость переписывать код и загружает его заново.

## Установка

Библиотека **RPulse** зависит от библиотеки [**GyverTimers**](https://github.com/GyverLibs/GyverTimers). В первую очередь, установите её.

### Через менеджер библиотек

Этот способ предпочтительнее, потому что Arduino IDE самостоятельно будет следить за обновлениями библиотеки и предложит их загрузить.

Откройте **Arduino IDE**. Откройте **Менеджер библиотек**. Для этого выберите пункт меню **Инструменты - Управлять библиотеками** или нажмите комбинацию клавиш <kbd>Ctrl</kbd> + <kbd>Shift</kbd> + <kbd>I</kbd>. В появившемся окне наберите в строке поиска название библиотеки и нажмите кнопку **Установка**. Через некоторое время последняя версии библиотеки будет загружена и установлена.

### Установка с помощью zip-архива

Если на компьютере нет доступа в интернет, нужно использовать этот способ.

По ссылке перейдите на [страницу релиза последней версии](https://github.com/InsightLabTools/RPulse/releases/latest). В разделе **Assets** скачайте архив с названием **Source code (zip)**. Файл будет называться **RPulse-[версия].zip**.

> Перед установкой новой версии библиотеки из zip-файла, удалите предыдущую версию!

Откройте **Arduino IDE**. Выберите пункт меню **Скетч - Подключить библиотеку - Добавить .ZIP библиотеку...** . В появившемся диалоговом окне выберите сохранённый ранее архив.

Перезапустите **Arduino IDE**.

Библиотека установлена.

## Примеры скетчей

Примеры можно найти в меню **Файл - Примеры - RPulse**.

Для быстрого старта используйте пример **Template**.

## Подключение

Для импорта библиотеки в скетч, нужно добавить в начале следующую строку:

```c++
#include <RPulse.h>
```

Добавить эту строку можно вручную или с помощью меню **Скетч - Подключить библиотеку - RPulse**.

## Документация

Перед тем, как обращаться к методам, нужно создать объект класса `RPulse`:

```c++
#include <RPulse.h> // подключение библиотеки

// объект класса RPulse создаётся вне функции setup() и loop()
RPulse pulse;

void setup(){
    // начальная настройка
}

void loop(){
    // главыный цикл Arduino-скетча
}
```

Для инициализации подключения нужно использовать следующий метод:

```c++
void init(baudRate = 9600, timer = T1);
```

`baudRate` - скорость передачи данных в бод. По умолчанию используется скорость 9600 бод, `timer` - выбор аппаратного таймера. Оба параметра имеют значения по умолчанию. Вызов метода нужно разместить в функции `setup()`:

```c++
void setup(){
    pulse.init(9600); // открытие подключения
}
```

Метод можно вызвать без параметров. Тогда скорость подключения будет равна 9600 бод, будет использоваться аппаратный таймер Timer1:

```c++
void setup(){
    pulse.init(); // открытие подключения
}
```

Параметр `timer` может принимать следующие значения, соответствующие аппаратным таймерам:

- `T0` - Timer0;
- `T1` - Timer1 (Используется по умолчанию);
- `T2` - Timer2.

Если нужно выбрать таймер, то в метод `init()` передаётся и скорость и название таймера:

```c++
void setup(){
    pulse.init(9600, T2); // использование таймера 2
}
```

> **Важно!**
>
> Отслеживание значений переменных будет работать только с `T1` (Timer1). С `T0` и `T2` будет работать только отслеживание значений на пинах.

Метод настраивает подключение через последовательный интерфейс, так что вызывать `Serial.begin()` повторно нет необходимости.

### Старт по команде и ожидание дополнительных параметров

Метод `wait()` ставит выполнение скетча на паузу в ожидании команды, передаваемой через последовательный порт. Метод нужно размещать в функции `setup()`.

```c++
void setup(){
    pulse.init(9600);
    ...
    pulse.wait(); // ожидание команды start
}
```

После вызова метода, скетч приостанавливает работу до поступления команды. Метод ожидает список параметров, которые затем будут использоваться в скетче.

Строка для передачи параметров должна иметь следующий вид:

```
p<ключ1:значение1|ключ2:значение2|;
```

Допустим мы хотим передать параметр `скорость` со значение 30, `коэффициент` со значением 0.8 и `угол` со значением 45. Строка для передачи будет выглядеть так:

```
p<скорость:30|коэффициент:0.8|угол:45|;
```

Как только скетч получит строку с параметрами, управление перейдёт следующему за методом `wait()` коду. 

Чтобы продолжить работу скетча без отправки параметров достаточно отправить следующую строку:

```
p<;
```

После этой команды метод `wait()` завершит свою работу и передаст управление следующей инструкции. Каждые 100 мс библиотека начнёт отправлять информацию с отслеживаемых пинов и значения отслеживаемых переменных.

### Запуск без ожидания команды

Если запуск скетча по команде не требуется, то используйте функцию `start()`:

```c++
void setup(){
    pulse.init();
    ...
    pulse.start(); // запуск отслеживания параметров
}
```

Контроллер начнёт отправлять отслеживаемые значения сразу же после выполнения этой функции.

### Отслеживание значений на пинах микроконтроллера

Чтобы отправлять значения, полученные с пинов используется следующий метод:

```c++
void watchPin(int pin, PinType type, String key);
```

Например, мы хотим следить за значением на аналоговом пине `A1`. Показания будем отправлять под названием _измерение_. Также добавим цифровой пин с номером 11 под названием _кнопка_:

```c++
void setup(){
    pusle.watchPin(A1, analog, "измерение"); // добавляем аналоговый пин
    pulse.watchPin(11, digital, "кнопка"); // добавляем цифровой пин
    pulse.wait();
}
```

Второй параметр метода определяет тип отправляемого сигнала:

-   `analog`: отправляем значение с аналогового пина - используется `analogRead()`;
-   `digital`: отправляем значение с цифрового пина - используется `digitalRead()`.

### Отслеживание значений переменных

Следить можно и за значениями переменных типа `int` и `float`:

```c++
void watchVar(int &var, String key);
void watchVar(float &var, String key);
```

Отслеживаемые переменные должны быть объявлены вне функций `setup()` и `loop()`.

В следующем примере будем следить за двумя переменными - `dist` и `range`:

```c++
float dist;
int range;

void setup(){
    pulse.watchVar(dist, "расстояние");
    pulse.watchVar(range, "диапазон");
    pulse.wait();
}
```

### Формат отслеживаемых данных

Каждые 100 мс микроконтроллер будет отправлять отслеживаемые значения, которые добавлены методами `watchPin()` и `watchVar()`. Формат строки, которая отправляется микроконтроллером выглядит так:

```
p>pin:измерение:251|pin:кнопка:0|var:расстояние:23.7|var:диапазон:52|=103
```

Информация о каждом из значений состоит из трёх частей, разделённых двоеточием: типа - переменная (var) или пин (pin), текста с описанием и числового значения.

Число после `=`  - количество байт в отправляемой строке (включая символ `=`). С помощью этого числа можно проверить корректность полученных данных.

### Использование полученных параметров в скетче

Переданные в скетч параметры можно получить с помощью следующего метода:

```c++
float get(String key, float defaultValue = 0.0);
```

Метод возвращает вещественное число. Первый параметр - ключ. Второй параметр не обязателен и определяет значение по умолчанию, если параметр с таким ключом не был получен.

К примеру, микроконтроллер получил следующий набор параметров:

```
p<скорость:30|коэффициент:0.8|;
```

Получить значения этих параметров в скетче можно так:

```c++
int speed = pulse.get("скорость"); // в переменной будет значение 30
float coef = pulse.get("коэффициент", 0.5); // в переменной будет значение 0.8
int angle = pulse.get("угол", 90.0); // в переменной будет значение 90, так как этот параметр не отправлялся
```
